# ЛР9. Вариант 1 _(Стек)_ + 5 _(Сортировка слиянием)_
### Слияние двух стеков, упорядоченных по возрастанию, с сохранения порядка
- `merge` – Слияние двух стеков и сортировка, клонирование стека
- `stack` – Реализация стека (на массиве)

>[!NOTE]
> CLI есть!
> Доступные команды:
>```
>print
>push {x}
>pop
>sort
>exit
>
>fill {n} // добавляет к стеку, а не `заменяет`
>{a1} {a2} {an}
>```

---


# Отчёт по лабораторной работе №9 по курсу "Фундаментальная информатика"

**Тема:** Абстраĸтные типы данных. Реĸурсия. Модульное программирование на языĸе Си

**Цель:** Освоить принципы работы с абстрактным типом данных "стек", реализовать сортировку стека методом слияния.

**Задание:** Реализовать стек на массиве и метод сортировки методом слияния с сохранением порядка элементов.  

> **Процедура:** Слияние двух стеков, упорядоченных по возрастанию, с сохранением порядка.  


## Идея и метод решения

Основная задача — отсортировать стек по возрастанию. Для этого:
- Реализован стек как динамический массив с автоматическим расширением
- Сортировка производится рекурсивно
- Все вспомогательные операции (разделение, слияние) реализованы **через интерфейс стека**: `push`, `pop`, `peek`, `is_empty`

Ключевая идея сортировки слиянием:
1. Стек делится на две (примерно) равные части с помощью временного стека
2. Каждая часть рекурсивно сортируется
3. Отсортированные части сливаются в новый стек, после чего результат копируется обратно

> [!IMPORTANT]  
> Поскольку стек предоставляет доступ **только к вершине**, для корректного слияния требуется несколько переворотов (через вспомогательные стеки), чтобы обеспечить порядок `[1, 2, 3] <- вершина`.

## Структура программы
Проект разбит на модули в соответствии с принципами модульного программирования:
- `main.c` – CLI, точка входа, взаимодействие с пользователем
- `stack.c / stack.h` – стек: push, pop, peek, print, create/destroy
- `merge.c / merge.h` – сортировка стека методом слияния, merge двух стеков
– `utils.c / utils.h` – вспомогательные функции (обработка ошибок)

Все данные стека инкапсулированы в `struct stack`; пользователь взаимодействует только через публичные функции.

## Алгоритм

### 1. Стек
- Создаётся динамический массив с начальной ёмкостью 4
- Автоматическое расширение при переполнении (умножение ёмкости на 2)
- Операции: `push`, `pop`, `peek`, `is_empty`, `size`, `print`
- Безопасность: проверка пустоты перед `pop`/`peek`, обработка нехватки памяти

### 2. Сортировка слиянием
1. Если `size ≤ 1` — возврат без изменений
2. **Переворот**: исходный стек копируется во временный, чтобы получить доступ к дну
3. **Разделение**: из временного стека формируются `left` и `right`
4. **Рекурсия**: `merge_sort_stack(left)`, `merge_sort_stack(right)`
5. **Слияние**:  
   - `left` и `right` переворачиваются (чтобы меньший элемент был на вершине)
   - поэлементное сравнение и слияние в `result`
   - `result` переворачивается и копируется обратно в исходный стек

> Все операции используют **только публичные функции стека** — доступ к `data[]` запрещён.

## Сценарий выполнения работы
1. Анализ задания и требований к АТД
2. Проектирование интерфейса стека и его реализация с динамическим расширением массива
3. Разработка рекурсивной сортировки слиянием без нарушения инкапсуляции
4. Реализация CLI-интерфейса
6. **Тестирование**

| **Команда**      | **Ввод / Состояние стека**      | **Результат**        |
|:----------------:|:-------------------------------:|:------------------------------:|
| `fill 5`<br>`4 2 5 1 3` | `[4, 2, 5, 1, 3] <- вершина`     |                 |
| `sort`           | `[1, 2, 3, 4, 5] <- вершина`    | Sorted   |
| `fill 0`         |                                | `N must be positive`           |
| `push 10` | `[1, 2, 3, 4, 5, 10] <- вершина`          | `Pushed 10`        |
| `pop`            | `[1, 2, 3, 4, 5] <- вершина`                             | `Popped 10`                     |
| `print`          | `[1, 2, 3, 4, 5] <- вершина`               | `[1, 2, 3, 4, 5] <- вершина`                     |
| `exit`           |                                | `Bye!`                         |

**Дополнительные тесты сортировки:**

| **До `sort`**     | **После `sort`** |
|:-----------------:|:----------------:|
| `[3, 1, 2]`       | `[1, 2, 3]`      |
| `[5, 5, 5]`       | `[5, 5, 5]`      |
| `[]`              | `[]`             |
| `[1]`             | `[1]`            |
| `[9, -1, 0, 7]`   | `[-1, 0, 7, 9]`  |

---

## Выводы

В ходе выполнения лабораторной работы был реализован стек, полностью инкапсулированный и соответствующий требованиям модульного программирования. 
Для него была реализована сортировка слиянием, использующая только публичные операции.

Работа продемонстрировала:
- Важность чистого API — реализация может меняться, но поведение остаётся стабильным
- Пользу **модульной декомпозиции** — логика стека и сортировки разделены, что упрощает отладку и расширение
